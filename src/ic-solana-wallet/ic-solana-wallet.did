type CommitmentLevel = variant { Finalized; Confirmed; Processed };
type ConsensusStrategy = variant { Equality; Threshold : nat8 };
type HttpHeader = record { value : text; name : text };
type InitArgs = record { schnorr_key : opt text; sol_canister : principal };
type JsonRpcError = record { code : int64; message : text };
type RejectionCode = variant {
  NoError;
  CanisterError;
  SysTransient;
  DestinationInvalid;
  Unknown;
  SysFatal;
  CanisterReject;
};
type Result = variant { Ok : text; Err : RpcError };
type RpcApi = record { network : text; headers : opt vec HttpHeader };
type RpcConfig = record {
  response_size_estimate : opt nat64;
  response_consensus : opt ConsensusStrategy;
};
type RpcError = variant {
  JsonRpcError : JsonRpcError;
  Text : text;
  InconsistentResponse : vec record { RpcApi; text };
  ValidationError : text;
  HttpOutcallError : record { code : RejectionCode; message : text };
  ParseError : text;
};
type RpcSendTransactionConfig = record {
  encoding : opt UiTransactionEncoding;
  min_context_slot : opt nat64;
  skip_preflight : bool;
  max_retries : opt nat64;
  preflight_commitment : opt CommitmentLevel;
};
type RpcServices = variant {
  Mainnet;
  Custom : vec RpcApi;
  Testnet;
  Devnet;
  Provider : vec text;
};
type UiTransactionEncoding = variant {
  Binary;
  JsonParsed;
  Json;
  Base58;
  Base64;
};
service : (InitArgs) -> {
  address : () -> (text);
  send_transaction : (
      RpcServices,
      opt RpcConfig,
      text,
      opt RpcSendTransactionConfig,
    ) -> (Result);
  sign_message : (text) -> (Result);
}
