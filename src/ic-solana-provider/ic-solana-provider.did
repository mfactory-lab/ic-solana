type Auth = variant { RegisterProvider; Manage };
type CommitmentConfig = record { commitment : CommitmentLevel };
type CommitmentLevel = variant { Finalized; Confirmed; Processed };
type ConsensusStrategy = variant { Equality; Threshold : nat8 };
type EncodedConfirmedTransactionWithStatusMeta = record {
  block_time : opt int64;
  transaction : EncodedTransactionWithStatusMeta;
  slot : nat64;
};
type EncodedTransaction = variant {
  Binary : record { text; TransactionBinaryEncoding };
  Json : UiTransaction;
  Accounts : UiAccountsList;
  LegacyBinary : text;
};
type EncodedTransactionWithStatusMeta = record {
  meta : opt UiTransactionStatusMeta;
  transaction : EncodedTransaction;
  version : opt TransactionVersion;
};
type EpochInfo = record {
  slots_in_epoch : nat64;
  absolute_slot : nat64;
  epoch : nat64;
  slot_index : nat64;
  transaction_count : opt nat64;
  block_height : nat64;
};
type EpochSchedule = record {
  leader_schedule_slot_offset : nat64;
  slots_per_epoch : nat64;
  first_normal_slot : nat64;
  warmup : bool;
  first_normal_epoch : nat64;
};
type HttpHeader = record { value : text; name : text };
type HttpOutcallError = variant {
  IcError : record { code : RejectionCode; message : text };
  InvalidHttpJsonRpcResponse : record {
    status : nat16;
    body : text;
    parsingError : opt text;
  };
};
type HttpRequest = record {
  url : text;
  method : text;
  body : blob;
  headers : vec record { text; text };
};
type HttpResponse = record {
  body : blob;
  headers : vec record { text; text };
  status_code : nat16;
};
type InitArgs = record {
  schnorr_key : opt text;
  managers : opt vec principal;
  demo : opt bool;
};
type JsonRpcError = record { code : int64; message : text };
type Legacy = variant { legacy };
type Memcmp = record {
  encoding : opt MemcmpEncoding;
  offset : nat64;
  bytes : MemcmpEncodedBytes;
};
type MemcmpEncodedBytes = variant {
  Binary : text;
  Bytes : blob;
  Base58 : text;
  Base64 : text;
};
type MemcmpEncoding = variant { Binary };
type MessageHeader = record {
  numReadonlySignedAccounts : nat8;
  numRequiredSignatures : nat8;
  numReadonlyUnsignedAccounts : nat8;
};
type Metrics = record {
  cyclesWithdrawn : nat;
  errUnauthorized : vec record { text; nat };
  auths : vec record { text; nat };
  responses : vec record { record { text; text; text }; nat64 };
  errNoPermission : nat64;
  inconsistentResponses : vec record { record { text; text }; nat64 };
  cyclesCharged : vec record { record { text; text }; nat };
  requests : vec record { record { text; text }; nat64 };
  errHttpOutcall : vec record { record { text; text }; nat64 };
  errHostNotAllowed : vec record { text; nat64 };
};
type ParsedAccount = record { space : nat64; parsed : text; program : text };
type ParsedInstruction = record {
  stackHeight : opt nat32;
  programId : text;
  parsed : blob;
  program : text;
};
type RegisterProviderArgs = record {
  id : text;
  url : text;
  auth : opt RpcAuth;
};
type RejectionCode = variant {
  NoError;
  CanisterError;
  SysTransient;
  DestinationInvalid;
  Unknown;
  SysFatal;
  CanisterReject;
};
type Result = variant { Ok : text; Err : RpcError };
type Result_1 = variant { Ok : vec RpcKeyedAccount; Err : RpcError };
type Result_10 = variant { Ok : vec RpcContactInfo; Err : RpcError };
type Result_11 = variant { Ok : EpochInfo; Err : RpcError };
type Result_12 = variant { Ok : EpochSchedule; Err : RpcError };
type Result_13 = variant { Ok : RpcSnapshotSlotInfo; Err : RpcError };
type Result_14 = variant { Ok : RpcIdentity; Err : RpcError };
type Result_15 = variant { Ok : RpcInflationGovernor; Err : RpcError };
type Result_16 = variant { Ok : RpcInflationRate; Err : RpcError };
type Result_17 = variant { Ok : vec opt RpcInflationReward; Err : RpcError };
type Result_18 = variant { Ok : vec RpcAccountBalance; Err : RpcError };
type Result_19 = variant { Ok : RpcBlockhash; Err : RpcError };
type Result_2 = variant { Ok : opt UiAccount; Err : RpcError };
type Result_20 = variant {
  Ok : vec record { text; vec nat64 };
  Err : RpcError;
};
type Result_21 = variant {
  Ok : opt EncodedConfirmedTransactionWithStatusMeta;
  Err : RpcError;
};
type Result_22 = variant {
  Ok : vec record { text; Result_21 };
  Err : RpcError;
};
type Result_23 = variant { Ok : vec UiAccount; Err : RpcError };
type Result_24 = variant { Ok : vec RpcPerfSample; Err : RpcError };
type Result_25 = variant { Ok : vec RpcPrioritizationFee; Err : RpcError };
type Result_26 = variant { Ok : vec opt TransactionStatus; Err : RpcError };
type Result_27 = variant {
  Ok : vec RpcConfirmedTransactionStatusWithSignature;
  Err : RpcError;
};
type Result_28 = variant { Ok : RpcSupply; Err : RpcError };
type Result_29 = variant { Ok : UiTokenAmount; Err : RpcError };
type Result_3 = variant { Ok : nat64; Err : RpcError };
type Result_30 = variant { Ok : vec TaggedRpcKeyedAccount; Err : RpcError };
type Result_31 = variant {
  Ok : vec TaggedRpcTokenAccountBalance;
  Err : RpcError;
};
type Result_32 = variant {
  Ok : TaggedEncodedConfirmedTransactionWithStatusMeta;
  Err : RpcError;
};
type Result_33 = variant { Ok : RpcVersionInfo; Err : RpcError };
type Result_34 = variant { Ok : RpcVoteAccountStatus; Err : RpcError };
type Result_35 = variant { Ok : bool; Err : RpcError };
type Result_36 = variant { Ok : RpcSimulateTransactionResult; Err : RpcError };
type Result_4 = variant { Ok; Err : TransactionError };
type Result_5 = variant { Ok : TaggedUiConfirmedBlock; Err : RpcError };
type Result_6 = variant { Ok : RpcBlockCommitment; Err : RpcError };
type Result_7 = variant { Ok : RpcBlockProduction; Err : RpcError };
type Result_8 = variant { Ok : int64; Err : RpcError };
type Result_9 = variant { Ok : vec nat64; Err : RpcError };
type Reward = record {
  lamports : int64;
  postBalance : nat64;
  commission : opt nat8;
  pubkey : text;
  rewardType : opt RewardType;
};
type RewardType = variant { Fee; Rent; Voting; Staking };
type RpcAccountBalance = record { lamports : nat64; address : text };
type RpcAccountInfoConfig = record {
  encoding : opt UiAccountEncoding;
  data_slice : opt UiDataSliceConfig;
  min_context_slot : opt nat64;
  commitment : opt CommitmentConfig;
};
type RpcApi = record { network : text; headers : opt vec HttpHeader };
type RpcAuth = variant {
  QueryParam : HttpHeader;
  BearerToken : record { token : text };
  PathSegment : record { segment : text };
  HeaderParam : HttpHeader;
};
type RpcBlockCommitment = record {
  total_stake : nat64;
  commitment : opt vec nat64;
};
type RpcBlockConfig = record {
  encoding : opt UiTransactionEncoding;
  rewards : opt bool;
  max_supported_transaction_version : opt nat8;
  transaction_details : opt TransactionDetails;
  commitment : opt CommitmentConfig;
};
type RpcBlockProduction = record {
  byIdentity : vec record { text; record { nat64; nat64 } };
  range : RpcBlockProductionRange;
};
type RpcBlockProductionRange = record {
  firstSlot : nat64;
  lastSlot : opt nat64;
};
type RpcBlockhash = record {
  blockhash : text;
  last_valid_block_height : nat64;
};
type RpcConfig = record {
  response_size_estimate : opt nat64;
  response_consensus : opt ConsensusStrategy;
};
type RpcConfirmedTransactionStatusWithSignature = record {
  err : opt TransactionError;
  signature : text;
  block_time : opt int64;
  memo : opt text;
  slot : nat64;
  confirmation_status : opt CommitmentLevel;
};
type RpcContactInfo = record {
  rpc : opt text;
  tpu : opt text;
  feature_set : opt nat32;
  gossip : opt text;
  pubkey : text;
  pubsub : opt text;
  shred_version : opt nat16;
  version : opt text;
  tpu_quic : opt text;
};
type RpcContextConfig = record {
  min_context_slot : opt nat64;
  commitment : opt CommitmentConfig;
};
type RpcEpochConfig = record {
  min_context_slot : opt nat64;
  epoch : opt nat64;
  commitment : opt CommitmentConfig;
};
type RpcError = variant {
  JsonRpcError : JsonRpcError;
  Text : text;
  InconsistentResponse : vec record { RpcApi; text };
  ValidationError : text;
  HttpOutcallError : HttpOutcallError;
  ParseError : text;
};
type RpcFilterType = variant {
  TokenAccountState;
  Memcmp : Memcmp;
  DataSize : nat64;
};
type RpcGetVoteAccountsConfig = record {
  delinquent_slot_distance : opt nat64;
  keep_unstaked_delinquents : opt bool;
  vote_pubkey : opt text;
  commitment : opt CommitmentConfig;
};
type RpcIdentity = record { identity : text };
type RpcInflationGovernor = record {
  taper : float64;
  foundation_term : float64;
  foundation : float64;
  initial : float64;
  terminal : float64;
};
type RpcInflationRate = record {
  total : float64;
  foundation : float64;
  validator : float64;
  epoch : nat64;
};
type RpcInflationReward = record {
  commission : opt nat8;
  epoch : nat64;
  effective_slot : nat64;
  amount : nat64;
  post_balance : nat64;
};
type RpcKeyedAccount = record { pubkey : text; account : UiAccount };
type RpcLargestAccountsConfig = record {
  filter : opt RpcLargestAccountsFilter;
  commitment : opt CommitmentConfig;
};
type RpcLargestAccountsFilter = variant { NonCirculating; Circulating };
type RpcLeaderScheduleConfig = record {
  identity : opt text;
  commitment : opt CommitmentConfig;
};
type RpcPerfSample = record {
  num_transactions : nat64;
  slot : nat64;
  sample_period_secs : nat16;
  num_slots : nat64;
  num_non_vote_transactions : opt nat64;
};
type RpcPrioritizationFee = record { prioritization_fee : nat64; slot : nat64 };
type RpcProgramAccountsConfig = record {
  filters : opt vec RpcFilterType;
  with_context : opt bool;
  account_config : RpcAccountInfoConfig;
};
type RpcSendTransactionConfig = record {
  encoding : opt UiTransactionEncoding;
  min_context_slot : opt nat64;
  skip_preflight : bool;
  max_retries : opt nat64;
  preflight_commitment : opt CommitmentLevel;
};
type RpcServices = variant { Custom : vec RpcApi; Provider : vec text };
type RpcSignatureStatusConfig = record { search_transaction_history : bool };
type RpcSignaturesForAddressConfig = record {
  min_context_slot : opt nat64;
  limit : opt nat64;
  before : opt text;
  until : opt text;
  commitment : opt CommitmentConfig;
};
type RpcSimulateTransactionAccountsConfig = record {
  encoding : opt UiAccountEncoding;
  addresses : vec text;
};
type RpcSimulateTransactionConfig = record {
  inner_instructions : bool;
  encoding : opt UiTransactionEncoding;
  replace_recent_blockhash : bool;
  min_context_slot : opt nat64;
  accounts : opt RpcSimulateTransactionAccountsConfig;
  commitment : opt CommitmentConfig;
  sig_verify : bool;
};
type RpcSimulateTransactionResult = record {
  err : opt TransactionError;
  inner_instructions : opt vec UiInnerInstructions;
  logs : opt vec text;
  return_data : opt UiTransactionReturnData;
  accounts : opt vec opt UiAccount;
  units_consumed : opt nat64;
};
type RpcSnapshotSlotInfo = record { full : nat64; incremental : opt nat64 };
type RpcSupply = record {
  total : nat64;
  circulating : nat64;
  non_circulating_accounts : vec text;
  non_circulating : nat64;
};
type RpcSupplyConfig = record {
  exclude_non_circulating_accounts_list : bool;
  commitment : opt CommitmentConfig;
};
type RpcTokenAccountsFilter = variant { Mint : text; ProgramId : text };
type RpcTransactionConfig = record {
  encoding : opt UiTransactionEncoding;
  max_supported_transaction_version : opt nat8;
  commitment : opt CommitmentConfig;
};
type RpcVersionInfo = record { feature_set : opt nat32; solana_core : text };
type RpcVoteAccountInfo = record {
  root_slot : nat64;
  commission : nat8;
  activated_stake : nat64;
  epoch_credits : vec record { nat64; nat64; nat64 };
  node_pubkey : text;
  last_vote : nat64;
  vote_pubkey : text;
  epoch_vote_account : bool;
};
type RpcVoteAccountStatus = record {
  current : vec RpcVoteAccountInfo;
  delinquent : vec RpcVoteAccountInfo;
};
type TaggedEncodedConfirmedTransactionWithStatusMeta = record {
  transaction : TaggedEncodedTransactionWithStatusMeta;
  slot : nat64;
  blockTime : opt int64;
};
type TaggedEncodedTransaction = variant {
  json : TaggedUiTransaction;
  accounts : UiAccountsList;
  legacyBinary : text;
  binary : record { text; TransactionBinaryEncoding };
};
type TaggedEncodedTransactionWithStatusMeta = record {
  meta : opt TaggedUiTransactionStatusMeta;
  transaction : TaggedEncodedTransaction;
  version : opt TransactionVersion;
};
type TaggedRpcBlockProductionConfig = record {
  identity : opt text;
  range : opt RpcBlockProductionRange;
  commitment : opt CommitmentConfig;
};
type TaggedRpcKeyedAccount = record {
  pubkey : text;
  account : TaggedUiAccount;
};
type TaggedRpcTokenAccountBalance = record {
  address : text;
  amount : UiTokenAmount;
};
type TaggedTransactionVersion = variant { legacy : Legacy; number : nat8 };
type TaggedUiAccount = record {
  executable : bool;
  owner : text;
  lamports : nat64;
  data : TaggedUiAccountData;
  space : opt nat64;
  rentEpoch : nat64;
};
type TaggedUiAccountData = variant {
  json : ParsedAccount;
  legacyBinary : text;
  binary : record { text; UiAccountEncoding };
};
type TaggedUiConfirmedBlock = record {
  blockTime : opt int64;
  blockhash : text;
  blockHeight : opt nat64;
  signatures : opt vec text;
  rewards : opt vec Reward;
  transactions : opt vec TaggedEncodedTransactionWithStatusMeta;
  numRewardPartitions : opt nat64;
  previousBlockhash : text;
  parentSlot : nat64;
};
type TaggedUiInnerInstructions = record {
  instructions : vec TaggedUiInstruction;
  index : nat8;
};
type TaggedUiInstruction = variant {
  compiled : UiCompiledInstruction;
  parsed : TaggedUiParsedInstruction;
};
type TaggedUiMessage = variant { raw : UiRawMessage; parsed : UiParsedMessage };
type TaggedUiParsedInstruction = variant {
  partiallyDecoded : UiPartiallyDecodedInstruction;
  parsed : ParsedInstruction;
};
type TaggedUiTransaction = record {
  message : TaggedUiMessage;
  signatures : vec text;
};
type TaggedUiTransactionStatusMeta = record {
  err : opt TransactionError;
  fee : nat64;
  status : Result_4;
  preBalances : vec nat64;
  postTokenBalances : opt vec UiTransactionTokenBalance;
  innerInstructions : opt vec TaggedUiInnerInstructions;
  postBalances : vec nat64;
  loadedAddresses : opt UiLoadedAddresses;
  rewards : opt vec Reward;
  logMessages : opt vec text;
  returnData : opt UiTransactionReturnData;
  preTokenBalances : opt vec UiTransactionTokenBalance;
  computeUnitsConsumed : opt nat64;
};
type TransactionBinaryEncoding = variant { Base58; Base64 };
type TransactionDetails = variant { Full; None; Accounts; Signatures };
type TransactionError = variant {
  InvalidAccountForFee;
  AddressLookupTableNotFound;
  MissingSignatureForFee;
  WouldExceedAccountDataBlockLimit;
  AccountInUse;
  DuplicateInstruction : nat8;
  AccountNotFound;
  TooManyAccountLocks;
  InvalidAccountIndex;
  AlreadyProcessed;
  WouldExceedAccountDataTotalLimit;
  InvalidAddressLookupTableIndex;
  SanitizeFailure;
  ResanitizationNeeded;
  InvalidRentPayingAccount;
  MaxLoadedAccountsDataSizeExceeded;
  InvalidAddressLookupTableData;
  InvalidWritableAccount;
  WouldExceedMaxAccountCostLimit;
  InvalidLoadedAccountsDataSizeLimit;
  InvalidProgramForExecution;
  InstructionError : record { nat8; text };
  InsufficientFundsForRent : record { account_index : nat8 };
  UnsupportedVersion;
  ClusterMaintenance;
  WouldExceedMaxVoteCostLimit;
  SignatureFailure;
  ProgramAccountNotFound;
  AccountLoadedTwice;
  ProgramExecutionTemporarilyRestricted : record { account_index : nat8 };
  AccountBorrowOutstanding;
  WouldExceedMaxBlockCostLimit;
  InvalidAddressLookupTableOwner;
  InsufficientFundsForFee;
  CallChainTooDeep;
  UnbalancedTransaction;
  BlockhashNotFound;
};
type TransactionStatus = record {
  err : opt TransactionError;
  confirmations : opt nat64;
  status : Result_4;
  slot : nat64;
  confirmation_status : opt CommitmentLevel;
};
type TransactionVersion = variant { legacy : Legacy; number : nat8 };
type UiAccount = record {
  executable : bool;
  owner : text;
  lamports : nat64;
  data : UiAccountData;
  space : opt nat64;
  rent_epoch : nat64;
};
type UiAccountData = variant {
  Binary : record { text; UiAccountEncoding };
  Json : ParsedAccount;
  LegacyBinary : text;
};
type UiAccountEncoding = variant {
  Binary;
  JsonParsed;
  "base64+zstd";
  Base58;
  Base64;
};
type UiAccountsList = record {
  signatures : vec text;
  account_keys : vec ParsedAccount;
};
type UiAddressTableLookup = record {
  accountKey : text;
  writableIndexes : blob;
  readonlyIndexes : blob;
};
type UiCompiledInstruction = record {
  data : text;
  accounts : blob;
  programIdIndex : nat8;
  stackHeight : opt nat32;
};
type UiDataSliceConfig = record { offset : nat64; length : nat64 };
type UiInnerInstructions = record {
  instructions : vec UiInstruction;
  index : nat8;
};
type UiInstruction = variant {
  Parsed : UiParsedInstruction;
  Compiled : UiCompiledInstruction;
};
type UiLoadedAddresses = record { writable : vec text; readonly : vec text };
type UiMessage = variant { Raw : UiRawMessage; Parsed : UiParsedMessage };
type UiParsedInstruction = variant {
  Parsed : ParsedInstruction;
  PartiallyDecoded : UiPartiallyDecodedInstruction;
};
type UiParsedMessage = record {
  addressTableLookups : opt vec UiAddressTableLookup;
  instructions : vec UiInstruction;
  accountKeys : vec ParsedAccount;
  recentBlockhash : text;
};
type UiPartiallyDecodedInstruction = record {
  data : text;
  accounts : vec text;
  stackHeight : opt nat32;
  programId : text;
};
type UiRawMessage = record {
  addressTableLookups : opt vec UiAddressTableLookup;
  instructions : vec UiCompiledInstruction;
  accountKeys : vec text;
  recentBlockhash : text;
  header : MessageHeader;
};
type UiReturnDataEncoding = variant { Base64 };
type UiTokenAmount = record {
  decimals : nat8;
  uiAmount : opt float64;
  uiAmountString : text;
  amount : text;
};
type UiTransaction = record { message : UiMessage; signatures : vec text };
type UiTransactionEncoding = variant {
  Binary;
  JsonParsed;
  Json;
  Base58;
  Base64;
};
type UiTransactionReturnData = record {
  data : record { text; UiReturnDataEncoding };
  program_id : text;
};
type UiTransactionStatusMeta = record {
  err : opt TransactionError;
  fee : nat64;
  status : Result_4;
  inner_instructions : opt vec UiInnerInstructions;
  post_token_balances : opt vec UiTransactionTokenBalance;
  pre_balances : vec nat64;
  post_balances : vec nat64;
  return_data : opt UiTransactionReturnData;
  log_messages : opt vec text;
  rewards : opt vec Reward;
  loaded_addresses : opt UiLoadedAddresses;
  pre_token_balances : opt vec UiTransactionTokenBalance;
  compute_units_consumed : opt nat64;
};
type UiTransactionTokenBalance = record {
  owner : opt text;
  mint : text;
  program_id : opt text;
  account_index : nat8;
  ui_token_amount : UiTokenAmount;
};
type UpdateProviderArgs = record {
  id : text;
  url : opt text;
  auth : opt RpcAuth;
};
service : (InitArgs) -> {
  authorize : (principal, Auth) -> (bool);
  deauthorize : (principal, Auth) -> (bool);
  getAuthorized : (Auth) -> (vec principal) query;
  getMetrics : () -> (Metrics) query;
  getNodesInSubnet : () -> (nat32) query;
  getProviders : () -> (vec text) query;
  http_request : (HttpRequest) -> (HttpResponse) query;
  registerProvider : (RegisterProviderArgs) -> ();
  request : (RpcServices, text, text, opt nat64) -> (Result);
  requestCost : (text, nat64) -> (nat) query;
  sel_getProgramAccounts : (
      RpcServices,
      opt RpcConfig,
      text,
      RpcProgramAccountsConfig,
    ) -> (Result_1);
  sol_getAccountInfo : (
      RpcServices,
      opt RpcConfig,
      text,
      opt RpcAccountInfoConfig,
    ) -> (Result_2);
  sol_getBalance : (RpcServices, opt RpcConfig, text, opt RpcContextConfig) -> (
      Result_3,
    );
  sol_getBlock : (RpcServices, opt RpcConfig, nat64, opt RpcBlockConfig) -> (
      Result_5,
    );
  sol_getBlockCommitment : (RpcServices, opt RpcConfig, nat64) -> (Result_6);
  sol_getBlockHeight : (RpcServices, opt RpcConfig, opt RpcContextConfig) -> (
      Result_3,
    );
  sol_getBlockProduction : (
      RpcServices,
      opt RpcConfig,
      TaggedRpcBlockProductionConfig,
    ) -> (Result_7);
  sol_getBlockTime : (RpcServices, opt RpcConfig, nat64) -> (Result_8);
  sol_getBlocks : (
      RpcServices,
      opt RpcConfig,
      nat64,
      opt nat64,
      opt CommitmentConfig,
    ) -> (Result_9);
  sol_getBlocksWithLimit : (
      RpcServices,
      opt RpcConfig,
      nat64,
      nat64,
      opt CommitmentConfig,
    ) -> (Result_9);
  sol_getClusterNodes : (RpcServices, opt RpcConfig) -> (Result_10);
  sol_getEpochInfo : (RpcServices, opt RpcConfig, opt RpcContextConfig) -> (
      Result_11,
    );
  sol_getEpochSchedule : (RpcServices, opt RpcConfig) -> (Result_12);
  sol_getFeeForMessage : (
      RpcServices,
      opt RpcConfig,
      text,
      opt RpcContextConfig,
    ) -> (Result_3);
  sol_getFirstAvailableBlock : (RpcServices, opt RpcConfig) -> (Result_3);
  sol_getGenesisHash : (RpcServices, opt RpcConfig) -> (Result);
  sol_getHealth : (RpcServices, opt RpcConfig) -> (Result);
  sol_getHighestSnapshotSlot : (RpcServices, opt RpcConfig) -> (Result_13);
  sol_getIdentity : (RpcServices, opt RpcConfig) -> (Result_14);
  sol_getInflationGovernor : (RpcServices, opt RpcConfig) -> (Result_15);
  sol_getInflationRate : (RpcServices, opt RpcConfig) -> (Result_16);
  sol_getInflationReward : (
      RpcServices,
      opt RpcConfig,
      vec text,
      RpcEpochConfig,
    ) -> (Result_17);
  sol_getLargestAccounts : (
      RpcServices,
      opt RpcConfig,
      opt RpcLargestAccountsConfig,
    ) -> (Result_18);
  sol_getLatestBlockhash : (
      RpcServices,
      opt RpcConfig,
      opt RpcContextConfig,
    ) -> (Result_19);
  sol_getLeaderSchedule : (
      RpcServices,
      opt RpcConfig,
      nat64,
      opt RpcLeaderScheduleConfig,
    ) -> (Result_20);
  sol_getLogs : (
      RpcServices,
      opt RpcConfig,
      text,
      opt RpcSignaturesForAddressConfig,
    ) -> (Result_22);
  sol_getMaxRetransmitSlot : (RpcServices, opt RpcConfig) -> (Result_3);
  sol_getMaxShredInsertSlot : (RpcServices, opt RpcConfig) -> (Result_3);
  sol_getMinimumBalanceForRentExemption : (
      RpcServices,
      opt RpcConfig,
      nat64,
      opt CommitmentConfig,
    ) -> (Result_3);
  sol_getMultipleAccounts : (
      RpcServices,
      opt RpcConfig,
      vec text,
      opt RpcAccountInfoConfig,
    ) -> (Result_23);
  sol_getRecentPerformanceSamples : (RpcServices, opt RpcConfig, nat64) -> (
      Result_24,
    );
  sol_getRecentPrioritizationFees : (RpcServices, opt RpcConfig, vec text) -> (
      Result_25,
    );
  sol_getSignatureStatuses : (
      RpcServices,
      opt RpcConfig,
      vec text,
      opt RpcSignatureStatusConfig,
    ) -> (Result_26);
  sol_getSignaturesForAddress : (
      RpcServices,
      opt RpcConfig,
      text,
      RpcSignaturesForAddressConfig,
    ) -> (Result_27);
  sol_getSlot : (RpcServices, opt RpcConfig, opt RpcContextConfig) -> (
      Result_3,
    );
  sol_getSlotLeader : (RpcServices, opt RpcConfig, opt RpcContextConfig) -> (
      Result,
    );
  sol_getSlotLeaders : (RpcServices, opt RpcConfig, nat64, opt nat64) -> (
      Result,
    );
  sol_getStakeMinimumDelegation : (
      RpcServices,
      opt RpcConfig,
      opt CommitmentConfig,
    ) -> (Result_3);
  sol_getSupply : (RpcServices, opt RpcConfig, RpcSupplyConfig) -> (Result_28);
  sol_getTokenAccountBalance : (
      RpcServices,
      opt RpcConfig,
      text,
      opt CommitmentConfig,
    ) -> (Result_29);
  sol_getTokenAccountsByDelegate : (
      RpcServices,
      opt RpcConfig,
      text,
      RpcTokenAccountsFilter,
      opt RpcAccountInfoConfig,
    ) -> (Result_30);
  sol_getTokenAccountsByOwner : (
      RpcServices,
      opt RpcConfig,
      text,
      RpcTokenAccountsFilter,
      opt RpcAccountInfoConfig,
    ) -> (Result_30);
  sol_getTokenLargestAccounts : (
      RpcServices,
      opt RpcConfig,
      text,
      opt CommitmentConfig,
    ) -> (Result_31);
  sol_getTokenSupply : (
      RpcServices,
      opt RpcConfig,
      text,
      opt CommitmentConfig,
    ) -> (Result_29);
  sol_getTransaction : (
      RpcServices,
      opt RpcConfig,
      text,
      opt RpcTransactionConfig,
    ) -> (Result_32);
  sol_getTransactionCount : (
      RpcServices,
      opt RpcConfig,
      opt RpcContextConfig,
    ) -> (Result_3);
  sol_getVersion : (RpcServices, opt RpcConfig) -> (Result_33);
  sol_getVoteAccounts : (
      RpcServices,
      opt RpcConfig,
      RpcGetVoteAccountsConfig,
    ) -> (Result_34);
  sol_isBlockhashValid : (
      RpcServices,
      opt RpcConfig,
      text,
      opt RpcContextConfig,
    ) -> (Result_35);
  sol_minimumLedgerSlot : (RpcServices, opt RpcConfig) -> (Result_3);
  sol_requestAirdrop : (RpcServices, opt RpcConfig, text, nat64) -> (Result);
  sol_sendTransaction : (
      RpcServices,
      opt RpcConfig,
      text,
      opt RpcSendTransactionConfig,
    ) -> (Result);
  sol_simulateTransaction : (
      RpcServices,
      opt RpcConfig,
      text,
      opt RpcSimulateTransactionConfig,
    ) -> (Result_36);
  unregisterProvider : (text) -> (bool);
  updateProvider : (UpdateProviderArgs) -> ();
}
